import { Router, Response, Request } from 'express'
import { getYahooFinanceService } from '../application/services/yahooFinanceService'
import { ApiError } from '@trading-viewer/shared'
import {
  validateSymbolSearch,
  validateCandleParams,
  validateQuoteParams,
  SymbolSearchRequest,
  CandleParamsRequest,
  QuoteParamsRequest,
} from '../middleware/validation'

const router: import('express').Router = Router()

// Check data source configuration
const USE_MOCK_DATA = process.env.USE_MOCK_DATA === 'true'

/**
 * テスト用のモックローソク足データを生成します。
 *
 * 開発時のレート制限回避のため、指定されたシンボルと期間に対して
 * ランダムな価格変動を含むリアルな OHLCV データを生成します。
 *
 * @param {string} symbol - 生成対象のシンボル（例: AAPL, GOOGL）
 * @param {string} resolution - 時間足の解像度（例: 1, 5, D）
 * @param {number} from - 開始タイムスタンプ（UNIX 時間）
 * @param {number} to - 終了タイムスタンプ（UNIX 時間）
 * @returns モックローソク足データオブジェクト
 *
 * @generated by Claude 🤖
 */
const generateMockCandleData = (symbol: string, resolution: string, from: number, to: number) => {
  const timeStep = resolution === 'D' ? 86400 : parseInt(resolution) * 60
  const points = Math.min(200, Math.floor((to - from) / timeStep))

  let basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100

  const data = {
    c: [] as number[],
    h: [] as number[],
    l: [] as number[],
    o: [] as number[],
    s: 'ok' as const,
    t: [] as number[],
    v: [] as number[],
  }

  for (let i = 0; i < points; i++) {
    const time = from + i * timeStep
    const variation = (Math.random() - 0.5) * 10
    const open = basePrice + variation
    const close = open + (Math.random() - 0.5) * 8
    const high = Math.max(open, close) + Math.random() * 3
    const low = Math.min(open, close) - Math.random() * 3
    const volume = Math.floor(Math.random() * 1000000) + 50000

    data.t.push(time)
    data.o.push(Number(open.toFixed(2)))
    data.h.push(Number(high.toFixed(2)))
    data.l.push(Number(low.toFixed(2)))
    data.c.push(Number(close.toFixed(2)))
    data.v.push(volume)

    basePrice = close // Trend continuation
  }

  return data
}

/**
 * テスト用のモック株価クオートデータを生成します。
 *
 * 指定されたシンボルに対して、現在価格、変動額、変動率、高値、安値、
 * 始値、前日終値、タイムスタンプを含むリアルなクオートデータを生成します。
 *
 * @param {string} symbol - 生成対象のシンボル（例: AAPL, GOOGL）
 * @returns モック株価クオートデータオブジェクト
 *
 * @generated by Claude 🤖
 */
const generateMockQuote = (symbol: string) => {
  const basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100
  const change = (Math.random() - 0.5) * 10
  const currentPrice = basePrice + change
  const previousClose = basePrice

  return {
    c: Number(currentPrice.toFixed(2)),
    d: Number(change.toFixed(2)),
    dp: Number(((change / previousClose) * 100).toFixed(2)),
    h: Number((currentPrice + Math.random() * 5).toFixed(2)),
    l: Number((currentPrice - Math.random() * 5).toFixed(2)),
    o: Number(previousClose.toFixed(2)),
    pc: Number(previousClose.toFixed(2)),
    t: Math.floor(Date.now() / 1000),
  }
}

// Mock symbol database for search
const MOCK_SYMBOLS = [
  {
    symbol: 'AAPL',
    description: 'Apple Inc',
    displaySymbol: 'AAPL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOGL',
    description: 'Alphabet Inc Class A',
    displaySymbol: 'GOOGL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOG',
    description: 'Alphabet Inc Class C',
    displaySymbol: 'GOOG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'MSFT',
    description: 'Microsoft Corporation',
    displaySymbol: 'MSFT',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'TSLA',
    description: 'Tesla Inc',
    displaySymbol: 'TSLA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMZN',
    description: 'Amazon.com Inc',
    displaySymbol: 'AMZN',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'META',
    description: 'Meta Platforms Inc',
    displaySymbol: 'META',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NVDA',
    description: 'NVIDIA Corporation',
    displaySymbol: 'NVDA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'JPM',
    description: 'JPMorgan Chase & Co',
    displaySymbol: 'JPM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'JNJ',
    description: 'Johnson & Johnson',
    displaySymbol: 'JNJ',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'V',
    description: 'Visa Inc Class A',
    displaySymbol: 'V',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PG',
    description: 'Procter & Gamble Company',
    displaySymbol: 'PG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'UNH',
    description: 'UnitedHealth Group Incorporated',
    displaySymbol: 'UNH',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'HD',
    description: 'Home Depot Inc',
    displaySymbol: 'HD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'MA',
    description: 'Mastercard Incorporated Class A',
    displaySymbol: 'MA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'DIS',
    description: 'Walt Disney Company',
    displaySymbol: 'DIS',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'BAC',
    description: 'Bank of America Corporation',
    displaySymbol: 'BAC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'ADBE',
    description: 'Adobe Inc',
    displaySymbol: 'ADBE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'CRM',
    description: 'Salesforce Inc',
    displaySymbol: 'CRM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'KO',
    description: 'Coca-Cola Company',
    displaySymbol: 'KO',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PFE',
    description: 'Pfizer Inc',
    displaySymbol: 'PFE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'INTC',
    description: 'Intel Corporation',
    displaySymbol: 'INTC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMD',
    description: 'Advanced Micro Devices Inc',
    displaySymbol: 'AMD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NFLX',
    description: 'Netflix Inc',
    displaySymbol: 'NFLX',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
]

/**
 * モックシンボルデータベース内を検索します。
 *
 * 指定されたクエリ文字列に基づいて、シンボル名または企業名で
 * マッチするシンボル情報を最大 limit 件まで返します。
 *
 * @param {string} query - 検索クエリ文字列
 * @param {number} limit - 返す結果の最大件数（デフォルト: 10）
 * @returns マッチしたシンボル情報の配列
 *
 * @generated by Claude 🤖
 */
const searchMockSymbols = (query: string, limit: number = 10) => {
  const q = query.toLowerCase().trim()
  if (!q) return []

  const results = MOCK_SYMBOLS.filter(
    symbol =>
      symbol.symbol.toLowerCase().includes(q) || symbol.description.toLowerCase().includes(q)
  ).slice(0, limit)

  return results
}

// Symbol search endpoint
router.get('/search', validateSymbolSearch, async (req: any, res: Response) => {
  try {
    const { q, limit } = req.validated

    // Use mock data for development to avoid rate limits
    if (USE_MOCK_DATA) {
      const symbols = searchMockSymbols(q.trim(), limit)
      res.json({
        symbols,
        query: q.trim(),
        count: symbols.length,
      })
      return
    }

    // Use Yahoo Finance API
    const yahooService = getYahooFinanceService()
    const results = await yahooService.searchSymbols(q.trim(), limit)

    const symbols = results.map(result => ({
      symbol: result.symbol,
      description: result.longname || result.shortname || result.symbol,
      displaySymbol: result.symbol,
      type: result.typeDisp || 'Common Stock',
      currency: 'USD',
      exchange: result.exchange || '',
    }))

    res.json({
      symbols,
      query: q.trim(),
      count: symbols.length,
    })
  } catch (error) {
    console.error('Symbol search error:', error)

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Batch quotes endpoint (NEW - for N+1 query optimization)
router.get('/quotes', async (req, res: Response) => {
  try {
    const symbolsParam = req.query.symbols as string

    if (!symbolsParam) {
      return res.status(400).json({
        code: 'MISSING_SYMBOLS',
        message: 'symbols query parameter is required',
        statusCode: 400,
      } as ApiError)
    }

    const symbols = symbolsParam
      .split(',')
      .map(s => s.trim().toUpperCase())
      .filter(Boolean)

    if (symbols.length === 0) {
      return res.status(400).json({
        code: 'INVALID_SYMBOLS',
        message: 'At least one valid symbol is required',
        statusCode: 400,
      } as ApiError)
    }

    // Limit batch size to prevent overload
    if (symbols.length > 50) {
      return res.status(400).json({
        code: 'TOO_MANY_SYMBOLS',
        message: 'Maximum 50 symbols allowed per request',
        statusCode: 400,
      } as ApiError)
    }

    const quotes: Record<string, any> = {}

    if (USE_MOCK_DATA) {
      // Generate mock quotes for all symbols
      for (const symbol of symbols) {
        quotes[symbol] = generateMockQuote(symbol)
      }
    } else {
      // Use Yahoo Finance API for batch fetching
      const yahooService = getYahooFinanceService()

      // Fetch quotes in parallel for better performance
      const quotePromises = symbols.map(async symbol => {
        try {
          const quote = await yahooService.getQuote(symbol)
          return {
            symbol,
            data: {
              c: quote.currentPrice,
              d: quote.change,
              dp: quote.changePercent,
              h: quote.high,
              l: quote.low,
              o: quote.open,
              pc: quote.previousClose,
              t: Math.floor(quote.timestamp / 1000),
            },
          }
        } catch (error) {
          console.error(`Quote fetch error for ${symbol}:`, error)
          return {
            symbol,
            error: 'Failed to fetch quote',
          }
        }
      })

      const results = await Promise.allSettled(quotePromises)

      results.forEach((result, index) => {
        const symbol = symbols[index]
        if (result.status === 'fulfilled' && result.value.data) {
          quotes[symbol] = result.value.data
        } else {
          quotes[symbol] = {
            error: result.status === 'rejected' ? 'Failed to fetch quote' : result.value.error,
          }
        }
      })
    }

    res.json({
      quotes,
      count: Object.keys(quotes).length,
      timestamp: Math.floor(Date.now() / 1000),
    })
  } catch (error) {
    console.error('Batch quotes error:', error)

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Real-time quote endpoint (single symbol)
router.get('/quote/:symbol', validateQuoteParams, async (req: any, res: Response) => {
  try {
    const { symbol } = req.validated

    // Use mock or real data based on configuration (no mixing)
    if (USE_MOCK_DATA) {
      const mockQuote = generateMockQuote(symbol.toUpperCase())
      res.json(mockQuote)
      return
    }

    // Use Yahoo Finance API
    const yahooService = getYahooFinanceService()
    const quote = await yahooService.getQuote(symbol.toUpperCase())

    // Convert Yahoo Finance format to expected format
    const responseQuote = {
      c: quote.currentPrice,
      d: quote.change,
      dp: quote.changePercent,
      h: quote.high,
      l: quote.low,
      o: quote.open,
      pc: quote.previousClose,
      t: Math.floor(quote.timestamp / 1000),
    }

    res.json(responseQuote)
  } catch (error) {
    console.error('Quote fetch error:', error)

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Historical candle data endpoint
router.get('/candles/:symbol', validateCandleParams, async (req: any, res: Response) => {
  try {
    const { symbol, resolution, from, to } = req.validated

    // Use mock or real data based on configuration (no mixing)
    if (USE_MOCK_DATA) {
      const mockCandleData = generateMockCandleData(symbol.toUpperCase(), resolution, from, to)
      res.json(mockCandleData)
      return
    }

    // Use Yahoo Finance API
    const yahooService = getYahooFinanceService()
    const candleData = await yahooService.getCandlesWithResolution(
      symbol.toUpperCase(),
      resolution,
      from,
      to
    )

    res.json(candleData)
  } catch (error) {
    console.error('Candle data fetch error:', error)

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Data source info endpoint
router.get('/data-source', (_req: Request, res: Response) => {
  try {
    let provider: string
    let status: string
    let description: string

    if (USE_MOCK_DATA) {
      provider = 'Mock Data'
      status = 'DEMO'
      description = 'Demo Data for Development'
    } else {
      provider = 'Yahoo Finance'
      status = 'LIVE'
      description = 'Market Data by Yahoo Finance'
    }

    res.json({
      isMockData: USE_MOCK_DATA,
      provider,
      status,
      description,
    })
  } catch (error) {
    console.error('Data source info error:', error)
    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Rate limit test endpoint
router.get('/rate-limit', (_req, res: Response) => {
  res.json({
    message: 'Rate limiting is configured',
    timestamp: Math.floor(Date.now() / 1000),
  })
})

export default router
