import { Router, Response, Request } from 'express'
import { getService } from '../infrastructure/di/container.js'
import { TYPES } from '../infrastructure/di/types.js'
import type { IYahooFinanceService } from '../infrastructure/di/interfaces.js'
import { ApiError } from '@trading-viewer/shared'
import {
  validateSymbolSearch,
  validateCandleParams,
  validateQuoteParams,
} from '../middleware/validation'
import { log } from '../infrastructure/services/logger'

const router: import('express').Router = Router()

// Check data source configuration
const USE_MOCK_DATA = process.env.USE_MOCK_DATA === 'true'

/**
 * ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
 *
 * é–‹ç™ºæ™‚ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™å›žé¿ã®ãŸã‚ã€æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ³ãƒœãƒ«ã¨æœŸé–“ã«å¯¾ã—ã¦
 * ãƒ©ãƒ³ãƒ€ãƒ ãªä¾¡æ ¼å¤‰å‹•ã‚’å«ã‚€ãƒªã‚¢ãƒ«ãª OHLCV ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
 *
 * @param {string} symbol - ç”Ÿæˆå¯¾è±¡ã®ã‚·ãƒ³ãƒœãƒ«ï¼ˆä¾‹: AAPL, GOOGLï¼‰
 * @param {string} resolution - æ™‚é–“è¶³ã®è§£åƒåº¦ï¼ˆä¾‹: 1, 5, Dï¼‰
 * @param {number} from - é–‹å§‹ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆUNIX æ™‚é–“ï¼‰
 * @param {number} to - çµ‚äº†ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆUNIX æ™‚é–“ï¼‰
 * @returns ãƒ¢ãƒƒã‚¯ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 *
 * @generated by Claude ðŸ¤–
 */
const generateMockCandleData = (symbol: string, resolution: string, from: number, to: number) => {
  const timeStep = resolution === 'D' ? 86400 : parseInt(resolution) * 60
  const points = Math.min(200, Math.floor((to - from) / timeStep))

  let basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100

  const data = {
    c: [] as number[],
    h: [] as number[],
    l: [] as number[],
    o: [] as number[],
    s: 'ok' as const,
    t: [] as number[],
    v: [] as number[],
  }

  for (let i = 0; i < points; i++) {
    const time = from + i * timeStep
    const variation = (Math.random() - 0.5) * 10
    const open = basePrice + variation
    const close = open + (Math.random() - 0.5) * 8
    const high = Math.max(open, close) + Math.random() * 3
    const low = Math.min(open, close) - Math.random() * 3
    const volume = Math.floor(Math.random() * 1000000) + 50000

    data.t.push(time)
    data.o.push(Number(open.toFixed(2)))
    data.h.push(Number(high.toFixed(2)))
    data.l.push(Number(low.toFixed(2)))
    data.c.push(Number(close.toFixed(2)))
    data.v.push(volume)

    basePrice = close // Trend continuation
  }

  return data
}

/**
 * ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯æ ªä¾¡ã‚¯ã‚ªãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
 *
 * æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ³ãƒœãƒ«ã«å¯¾ã—ã¦ã€ç¾åœ¨ä¾¡æ ¼ã€å¤‰å‹•é¡ã€å¤‰å‹•çŽ‡ã€é«˜å€¤ã€å®‰å€¤ã€
 * å§‹å€¤ã€å‰æ—¥çµ‚å€¤ã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å«ã‚€ãƒªã‚¢ãƒ«ãªã‚¯ã‚ªãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
 *
 * @param {string} symbol - ç”Ÿæˆå¯¾è±¡ã®ã‚·ãƒ³ãƒœãƒ«ï¼ˆä¾‹: AAPL, GOOGLï¼‰
 * @returns ãƒ¢ãƒƒã‚¯æ ªä¾¡ã‚¯ã‚ªãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 *
 * @generated by Claude ðŸ¤–
 */
const generateMockQuote = (
  symbol: string
): {
  symbol: string
  currentPrice: number
  change: number
  changePercent: number
  [key: string]: unknown
} => {
  const basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100
  const change = (Math.random() - 0.5) * 10
  const currentPrice = basePrice + change
  const previousClose = basePrice

  return {
    symbol,
    currentPrice: Number(currentPrice.toFixed(2)),
    change: Number(change.toFixed(2)),
    changePercent: Number(((change / previousClose) * 100).toFixed(2)),
    c: Number(currentPrice.toFixed(2)),
    d: Number(change.toFixed(2)),
    dp: Number(((change / previousClose) * 100).toFixed(2)),
    h: Number((currentPrice + Math.random() * 5).toFixed(2)),
    l: Number((currentPrice - Math.random() * 5).toFixed(2)),
    o: Number(previousClose.toFixed(2)),
    pc: Number(previousClose.toFixed(2)),
    t: Math.floor(Date.now() / 1000),
  }
}

// Mock symbol database for search
const MOCK_SYMBOLS = [
  {
    symbol: 'AAPL',
    description: 'Apple Inc',
    displaySymbol: 'AAPL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOGL',
    description: 'Alphabet Inc Class A',
    displaySymbol: 'GOOGL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOG',
    description: 'Alphabet Inc Class C',
    displaySymbol: 'GOOG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'MSFT',
    description: 'Microsoft Corporation',
    displaySymbol: 'MSFT',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'TSLA',
    description: 'Tesla Inc',
    displaySymbol: 'TSLA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMZN',
    description: 'Amazon.com Inc',
    displaySymbol: 'AMZN',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'META',
    description: 'Meta Platforms Inc',
    displaySymbol: 'META',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NVDA',
    description: 'NVIDIA Corporation',
    displaySymbol: 'NVDA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'JPM',
    description: 'JPMorgan Chase & Co',
    displaySymbol: 'JPM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'JNJ',
    description: 'Johnson & Johnson',
    displaySymbol: 'JNJ',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'V',
    description: 'Visa Inc Class A',
    displaySymbol: 'V',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PG',
    description: 'Procter & Gamble Company',
    displaySymbol: 'PG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'UNH',
    description: 'UnitedHealth Group Incorporated',
    displaySymbol: 'UNH',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'HD',
    description: 'Home Depot Inc',
    displaySymbol: 'HD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'MA',
    description: 'Mastercard Incorporated Class A',
    displaySymbol: 'MA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'DIS',
    description: 'Walt Disney Company',
    displaySymbol: 'DIS',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'BAC',
    description: 'Bank of America Corporation',
    displaySymbol: 'BAC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'ADBE',
    description: 'Adobe Inc',
    displaySymbol: 'ADBE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'CRM',
    description: 'Salesforce Inc',
    displaySymbol: 'CRM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'KO',
    description: 'Coca-Cola Company',
    displaySymbol: 'KO',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PFE',
    description: 'Pfizer Inc',
    displaySymbol: 'PFE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'INTC',
    description: 'Intel Corporation',
    displaySymbol: 'INTC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMD',
    description: 'Advanced Micro Devices Inc',
    displaySymbol: 'AMD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NFLX',
    description: 'Netflix Inc',
    displaySymbol: 'NFLX',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
]

/**
 * ãƒ¢ãƒƒã‚¯ã‚·ãƒ³ãƒœãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã‚’æ¤œç´¢ã—ã¾ã™ã€‚
 *
 * æŒ‡å®šã•ã‚ŒãŸã‚¯ã‚¨ãƒªæ–‡å­—åˆ—ã«åŸºã¥ã„ã¦ã€ã‚·ãƒ³ãƒœãƒ«åã¾ãŸã¯ä¼æ¥­åã§
 * ãƒžãƒƒãƒã™ã‚‹ã‚·ãƒ³ãƒœãƒ«æƒ…å ±ã‚’æœ€å¤§ limit ä»¶ã¾ã§è¿”ã—ã¾ã™ã€‚
 *
 * @param {string} query - æ¤œç´¢ã‚¯ã‚¨ãƒªæ–‡å­—åˆ—
 * @param {number} limit - è¿”ã™çµæžœã®æœ€å¤§ä»¶æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 10ï¼‰
 * @returns ãƒžãƒƒãƒã—ãŸã‚·ãƒ³ãƒœãƒ«æƒ…å ±ã®é…åˆ—
 *
 * @generated by Claude ðŸ¤–
 */
const searchMockSymbols = (query: string, limit: number = 10) => {
  const q = query.toLowerCase().trim()
  if (!q) return []

  const results = MOCK_SYMBOLS.filter(
    symbol =>
      symbol.symbol.toLowerCase().includes(q) || symbol.description.toLowerCase().includes(q)
  ).slice(0, limit)

  return results
}

// Symbol search endpoint
router.get('/search', validateSymbolSearch, async (req: Request, res: Response) => {
  try {
    const { q, limit } = req.query as { q: string; limit?: string }

    // Use mock data for development to avoid rate limits
    if (USE_MOCK_DATA) {
      const symbols = searchMockSymbols(q.trim(), Number(limit) || 10)
      res.json({
        symbols,
        query: q.trim(),
        count: symbols.length,
      })
      return
    }

    // Use Yahoo Finance API
    const yahooService = getService<IYahooFinanceService>(TYPES.YahooFinanceService)
    const results = await yahooService.searchSymbols(q.trim(), Number(limit) || 10)

    const symbols = results.map(result => ({
      symbol: result.symbol,
      description: result.longname || result.shortname || result.symbol,
      displaySymbol: result.symbol,
      type: result.typeDisp || 'Common Stock',
      currency: 'USD',
      exchange: result.exchange || '',
    }))

    res.json({
      symbols,
      query: q.trim(),
      count: symbols.length,
    })
  } catch (error) {
    log.api.error('Symbol search error', error, { query: (req.query as { q: string })?.q })

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Batch quotes endpoint (NEW - for N+1 query optimization)
router.get('/quotes', async (req, res: Response) => {
  try {
    const symbolsParam = req.query.symbols as string

    if (!symbolsParam) {
      return res.status(400).json({
        code: 'MISSING_SYMBOLS',
        message: 'symbols query parameter is required',
        statusCode: 400,
      } as ApiError)
    }

    const symbols = symbolsParam
      .split(',')
      .map(s => s.trim().toUpperCase())
      .filter(Boolean)

    if (symbols.length === 0) {
      return res.status(400).json({
        code: 'INVALID_SYMBOLS',
        message: 'At least one valid symbol is required',
        statusCode: 400,
      } as ApiError)
    }

    // Limit batch size to prevent overload
    if (symbols.length > 50) {
      return res.status(400).json({
        code: 'TOO_MANY_SYMBOLS',
        message: 'Maximum 50 symbols allowed per request',
        statusCode: 400,
      } as ApiError)
    }

    const quotes: Record<
      string,
      {
        symbol: string
        currentPrice: number
        change: number
        changePercent: number
        [key: string]: unknown
      }
    > = {}

    if (USE_MOCK_DATA) {
      // Generate mock quotes for all symbols
      for (const symbol of symbols) {
        quotes[symbol] = generateMockQuote(symbol)
      }
    } else {
      // Use Yahoo Finance API for batch fetching
      const yahooService = getService<IYahooFinanceService>(TYPES.YahooFinanceService)

      // Fetch quotes in parallel for better performance
      const quotePromises = symbols.map(async symbol => {
        try {
          const quote = await yahooService.getQuote(symbol)
          return {
            symbol,
            data: {
              c: quote.currentPrice,
              d: quote.change,
              dp: quote.changePercent,
              h: quote.high,
              l: quote.low,
              o: quote.open,
              pc: quote.previousClose,
              t: Math.floor(quote.timestamp / 1000),
            },
          }
        } catch (error) {
          log.api.error(`Quote fetch error for ${symbol}`, error, { symbol })
          return {
            symbol,
            error: 'Failed to fetch quote',
          }
        }
      })

      const results = await Promise.allSettled(quotePromises)

      results.forEach((result, index) => {
        const symbol = symbols[index]
        if (result.status === 'fulfilled' && result.value.data) {
          quotes[symbol] = {
            symbol,
            currentPrice: result.value.data.c,
            change: result.value.data.d,
            changePercent: result.value.data.dp,
            ...result.value.data,
          }
        } else {
          quotes[symbol] = {
            symbol,
            currentPrice: 0,
            change: 0,
            changePercent: 0,
            error: result.status === 'rejected' ? 'Failed to fetch quote' : result.value.error,
          }
        }
      })
    }

    res.json({
      quotes,
      count: Object.keys(quotes).length,
      timestamp: Math.floor(Date.now() / 1000),
    })
  } catch (error) {
    log.api.error('Batch quotes error', error, { symbolsCount: req.body?.symbols?.length })

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Real-time quote endpoint (single symbol)
router.get('/quote/:symbol', validateQuoteParams, async (req: Request, res: Response) => {
  try {
    const { symbol } = req.params as { symbol: string }

    // Use mock or real data based on configuration (no mixing)
    if (USE_MOCK_DATA) {
      const mockQuote = generateMockQuote(symbol.toUpperCase())
      res.json(mockQuote)
      return
    }

    // Use Yahoo Finance API
    const yahooService = getService<IYahooFinanceService>(TYPES.YahooFinanceService)
    const quote = await yahooService.getQuote(symbol.toUpperCase())

    // Convert Yahoo Finance format to expected format
    const responseQuote = {
      c: quote.currentPrice,
      d: quote.change,
      dp: quote.changePercent,
      h: quote.high,
      l: quote.low,
      o: quote.open,
      pc: quote.previousClose,
      t: Math.floor(quote.timestamp / 1000),
    }

    res.json(responseQuote)
  } catch (error) {
    log.api.error('Quote fetch error', error, {
      symbol: (req.params as { symbol: string })?.symbol,
    })

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Historical candle data endpoint
router.get('/candles/:symbol', validateCandleParams, async (req: Request, res: Response) => {
  try {
    const { symbol, resolution, from, to } = req.query as {
      symbol: string
      resolution: string
      from: string
      to: string
    }

    // Use mock or real data based on configuration (no mixing)
    if (USE_MOCK_DATA) {
      const mockCandleData = generateMockCandleData(
        symbol.toUpperCase(),
        resolution,
        Number(from),
        Number(to)
      )
      res.json(mockCandleData)
      return
    }

    // Use Yahoo Finance API
    const yahooService = getService<IYahooFinanceService>(TYPES.YahooFinanceService)
    const candleData = await yahooService.getCandlesWithResolution(
      symbol.toUpperCase(),
      resolution,
      Number(from),
      Number(to)
    )

    res.json(candleData)
  } catch (error) {
    log.api.error('Candle data fetch error', error, {
      symbol: (req.query as { symbol: string })?.symbol,
      resolution: (req.query as { resolution: string })?.resolution,
    })

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Data source info endpoint
router.get('/data-source', (_req: Request, res: Response) => {
  try {
    let provider: string
    let status: string
    let description: string

    if (USE_MOCK_DATA) {
      provider = 'Mock Data'
      status = 'DEMO'
      description = 'Demo Data for Development'
    } else {
      provider = 'Yahoo Finance'
      status = 'LIVE'
      description = 'Market Data by Yahoo Finance'
    }

    res.json({
      isMockData: USE_MOCK_DATA,
      provider,
      status,
      description,
    })
  } catch (error) {
    log.api.error('Data source info error', error)
    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Rate limit test endpoint
router.get('/rate-limit', (_req, res: Response) => {
  res.json({
    message: 'Rate limiting is configured',
    timestamp: Math.floor(Date.now() / 1000),
  })
})

export default router
