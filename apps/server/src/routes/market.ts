import { Router, Response } from 'express'
import { getFinnhubService } from '../services/finnhubService'
import { SymbolSearchParams, QuoteParams, CandleDataParams, ApiError } from '@trading-viewer/shared'
import {
  validateSymbolSearch,
  validateCandleParams,
  validateQuoteParams,
  SymbolSearchRequest,
  CandleParamsRequest,
  QuoteParamsRequest,
} from '../middleware/validation'

const router = Router()

// Check if we should use mock data
const USE_MOCK_DATA = process.env.USE_MOCK_DATA === 'true'

/**
 * テスト用のモックローソク足データを生成します。
 *
 * 開発時のレート制限回避のため、指定されたシンボルと期間に対して
 * ランダムな価格変動を含むリアルな OHLCV データを生成します。
 *
 * @param {string} symbol - 生成対象のシンボル（例: AAPL, GOOGL）
 * @param {string} resolution - 時間足の解像度（例: 1, 5, D）
 * @param {number} from - 開始タイムスタンプ（UNIX 時間）
 * @param {number} to - 終了タイムスタンプ（UNIX 時間）
 * @returns モックローソク足データオブジェクト
 *
 * @generated by Claude 🤖
 */
const generateMockCandleData = (symbol: string, resolution: string, from: number, to: number) => {
  const timeStep = resolution === 'D' ? 86400 : parseInt(resolution) * 60
  const points = Math.min(200, Math.floor((to - from) / timeStep))

  let basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100

  const data = {
    c: [] as number[],
    h: [] as number[],
    l: [] as number[],
    o: [] as number[],
    s: 'ok' as const,
    t: [] as number[],
    v: [] as number[],
  }

  for (let i = 0; i < points; i++) {
    const time = from + i * timeStep
    const variation = (Math.random() - 0.5) * 10
    const open = basePrice + variation
    const close = open + (Math.random() - 0.5) * 8
    const high = Math.max(open, close) + Math.random() * 3
    const low = Math.min(open, close) - Math.random() * 3
    const volume = Math.floor(Math.random() * 1000000) + 50000

    data.t.push(time)
    data.o.push(Number(open.toFixed(2)))
    data.h.push(Number(high.toFixed(2)))
    data.l.push(Number(low.toFixed(2)))
    data.c.push(Number(close.toFixed(2)))
    data.v.push(volume)

    basePrice = close // Trend continuation
  }

  return data
}

/**
 * テスト用のモック株価クオートデータを生成します。
 *
 * 指定されたシンボルに対して、現在価格、変動額、変動率、高値、安値、
 * 始値、前日終値、タイムスタンプを含むリアルなクオートデータを生成します。
 *
 * @param {string} symbol - 生成対象のシンボル（例: AAPL, GOOGL）
 * @returns モック株価クオートデータオブジェクト
 *
 * @generated by Claude 🤖
 */
const generateMockQuote = (symbol: string) => {
  const basePrice =
    symbol === 'AAPL' ? 150 : symbol === 'GOOGL' ? 2500 : symbol === 'TSLA' ? 200 : 100
  const change = (Math.random() - 0.5) * 10
  const currentPrice = basePrice + change
  const previousClose = basePrice

  return {
    c: Number(currentPrice.toFixed(2)),
    d: Number(change.toFixed(2)),
    dp: Number(((change / previousClose) * 100).toFixed(2)),
    h: Number((currentPrice + Math.random() * 5).toFixed(2)),
    l: Number((currentPrice - Math.random() * 5).toFixed(2)),
    o: Number(previousClose.toFixed(2)),
    pc: Number(previousClose.toFixed(2)),
    t: Math.floor(Date.now() / 1000),
  }
}

// Mock symbol database for search
const MOCK_SYMBOLS = [
  {
    symbol: 'AAPL',
    description: 'Apple Inc',
    displaySymbol: 'AAPL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOGL',
    description: 'Alphabet Inc Class A',
    displaySymbol: 'GOOGL',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'GOOG',
    description: 'Alphabet Inc Class C',
    displaySymbol: 'GOOG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'MSFT',
    description: 'Microsoft Corporation',
    displaySymbol: 'MSFT',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'TSLA',
    description: 'Tesla Inc',
    displaySymbol: 'TSLA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMZN',
    description: 'Amazon.com Inc',
    displaySymbol: 'AMZN',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'META',
    description: 'Meta Platforms Inc',
    displaySymbol: 'META',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NVDA',
    description: 'NVIDIA Corporation',
    displaySymbol: 'NVDA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'JPM',
    description: 'JPMorgan Chase & Co',
    displaySymbol: 'JPM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'JNJ',
    description: 'Johnson & Johnson',
    displaySymbol: 'JNJ',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'V',
    description: 'Visa Inc Class A',
    displaySymbol: 'V',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PG',
    description: 'Procter & Gamble Company',
    displaySymbol: 'PG',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'UNH',
    description: 'UnitedHealth Group Incorporated',
    displaySymbol: 'UNH',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'HD',
    description: 'Home Depot Inc',
    displaySymbol: 'HD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'MA',
    description: 'Mastercard Incorporated Class A',
    displaySymbol: 'MA',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'DIS',
    description: 'Walt Disney Company',
    displaySymbol: 'DIS',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'BAC',
    description: 'Bank of America Corporation',
    displaySymbol: 'BAC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'ADBE',
    description: 'Adobe Inc',
    displaySymbol: 'ADBE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'CRM',
    description: 'Salesforce Inc',
    displaySymbol: 'CRM',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'KO',
    description: 'Coca-Cola Company',
    displaySymbol: 'KO',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'PFE',
    description: 'Pfizer Inc',
    displaySymbol: 'PFE',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NEW YORK STOCK EXCHANGE',
  },
  {
    symbol: 'INTC',
    description: 'Intel Corporation',
    displaySymbol: 'INTC',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'AMD',
    description: 'Advanced Micro Devices Inc',
    displaySymbol: 'AMD',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
  {
    symbol: 'NFLX',
    description: 'Netflix Inc',
    displaySymbol: 'NFLX',
    type: 'Common Stock',
    currency: 'USD',
    exchange: 'NASDAQ NMS - GLOBAL MARKET',
  },
]

/**
 * モックシンボルデータベース内を検索します。
 *
 * 指定されたクエリ文字列に基づいて、シンボル名または企業名で
 * マッチするシンボル情報を最大 limit 件まで返します。
 *
 * @param {string} query - 検索クエリ文字列
 * @param {number} limit - 返す結果の最大件数（デフォルト: 10）
 * @returns マッチしたシンボル情報の配列
 *
 * @generated by Claude 🤖
 */
const searchMockSymbols = (query: string, limit: number = 10) => {
  const q = query.toLowerCase().trim()
  if (!q) return []

  const results = MOCK_SYMBOLS.filter(
    symbol =>
      symbol.symbol.toLowerCase().includes(q) || symbol.description.toLowerCase().includes(q)
  ).slice(0, limit)

  return results
}

// Symbol search endpoint
router.get('/search', validateSymbolSearch, async (req: SymbolSearchRequest, res: Response) => {
  try {
    const { q, limit } = req.validated

    // Return mock data for development to avoid rate limits
    const symbols = searchMockSymbols(q.trim(), limit)
    res.json({
      symbols,
      query: q.trim(),
      count: symbols.length,
    })
    return

    // Commented out real API call
    // const params: SymbolSearchParams = {
    //   q: q.trim(),
    //   limit
    // }
    // const finnhubService = getFinnhubService()
    // const symbols = await finnhubService.searchSymbols(params)
    // res.json({
    //   symbols,
    //   query: params.q,
    //   count: symbols.length
    // })
  } catch (error) {
    console.error('Symbol search error:', error)

    if ((error as ApiError).code) {
      const apiError = error as ApiError
      return res.status(apiError.statusCode).json(apiError)
    }

    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Real-time quote endpoint
router.get(
  '/quote/:symbol',
  validateQuoteParams,
  async (req: QuoteParamsRequest, res: Response) => {
    try {
      const { symbol } = req.validated

      // Use mock or real data based on configuration (no mixing)
      if (USE_MOCK_DATA) {
        console.log(`📈 Using MOCK data for quote: ${symbol} (USE_MOCK_DATA=true)`)
        const mockQuote = generateMockQuote(symbol.toUpperCase())
        res.json(mockQuote)
        return
      }

      // Use real Finnhub API data (no fallback to maintain consistency)
      console.log(`📈 Using REAL Finnhub data for quote: ${symbol} (USE_MOCK_DATA=false)`)
      const params: QuoteParams = {
        symbol: symbol.toUpperCase()
      }
      const finnhubService = getFinnhubService()
      const quote = await finnhubService.getQuote(params)
      res.json(quote)
    } catch (error) {
      console.error('Quote fetch error:', error)

      if ((error as ApiError).code) {
        const apiError = error as ApiError
        return res.status(apiError.statusCode).json(apiError)
      }

      res.status(500).json({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error',
        statusCode: 500,
      } as ApiError)
    }
  }
)

// Historical candle data endpoint
router.get(
  '/candles/:symbol',
  validateCandleParams,
  async (req: CandleParamsRequest, res: Response) => {
    try {
      const { symbol, resolution, from, to } = req.validated

      // Use mock or real data based on configuration (no mixing)
      if (USE_MOCK_DATA) {
        console.log(`📊 Using MOCK data for candles: ${symbol} (USE_MOCK_DATA=true)`)
        const mockCandleData = generateMockCandleData(symbol.toUpperCase(), resolution, from, to)
        res.json(mockCandleData)
        return
      }

      // Use real Finnhub API data (no fallback to maintain consistency)
      console.log(`📊 Using REAL Finnhub data for candles: ${symbol} (USE_MOCK_DATA=false)`)
      const params: CandleDataParams = {
        symbol: symbol.toUpperCase(),
        resolution,
        from,
        to
      }
      const finnhubService = getFinnhubService()
      const candleData = await finnhubService.getCandleData(params)
      res.json(candleData)
    } catch (error) {
      console.error('Candle data fetch error:', error)

      if ((error as ApiError).code) {
        const apiError = error as ApiError
        return res.status(apiError.statusCode).json(apiError)
      }

      res.status(500).json({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error',
        statusCode: 500,
      } as ApiError)
    }
  }
)

// Data source info endpoint
router.get('/data-source', (_req: Request, res: Response) => {
  try {
    res.json({
      isMockData: USE_MOCK_DATA,
      provider: USE_MOCK_DATA ? 'Mock Data' : 'Finnhub',
      status: USE_MOCK_DATA ? 'DEMO' : 'LIVE',
      description: USE_MOCK_DATA ? 'Demo Data for Development' : 'Market Data by Finnhub'
    })
  } catch (error) {
    console.error('Data source info error:', error)
    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

// Rate limit info endpoint
router.get('/rate-limit', (_req: Request, res: Response) => {
  try {
    const finnhubService = getFinnhubService()
    const rateLimitInfo = finnhubService.getRateLimitInfo()
    res.json({
      ...rateLimitInfo,
      canMakeRequest: finnhubService.canMakeRequest(),
      timeUntilReset: finnhubService.getTimeUntilReset(),
    })
  } catch (error) {
    console.error('Rate limit info error:', error)
    res.status(500).json({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Internal server error',
      statusCode: 500,
    } as ApiError)
  }
})

export default router
