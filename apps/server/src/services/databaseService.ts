import { PrismaClient } from '@prisma/client'
import {
  SymbolRepository,
  CandleRepository,
  UserPreferencesRepository,
  ISymbolRepository,
  ICandleRepository,
  IUserPreferencesRepository,
} from '../repositories'

/**
 * 取引データ用のコアデータベースサービスインターフェースです。
 *
 * シンボル、ローソク足、ユーザー設定のリポジトリへの一元アクセスを提供し、
 * トランザクション支援とヘルスモニタリング機能を含みます。
 *
 * @generated by Claude 🤖
 */
export interface IDatabaseService {
  symbols: ISymbolRepository
  candles: ICandleRepository
  userPreferences: IUserPreferencesRepository
  startTransaction(): Promise<DatabaseTransaction>
  isHealthy(): Promise<boolean>
  cleanup(): Promise<void>
}

/**
 * アトミック操作用のデータベーストランザクションラッパーです。
 *
 * データベーストランザクションコンテキスト内でのリポジトリアクセスを提供し、
 * データ整合性のための明示的なコミットとロールバック制御を行います。
 *
 * @generated by Claude 🤖
 */
export interface DatabaseTransaction {
  symbols: ISymbolRepository
  candles: ICandleRepository
  userPreferences: IUserPreferencesRepository
  commit(): Promise<void>
  rollback(): Promise<void>
}

/**
 * 取引アプリケーション用のメインデータベースサービスクラスです。
 *
 * Prisma ORM を使用してデータベース操作を抽象化し、シンボル、ローソク足、
 * ユーザー設定の各リポジトリへの統一アクセスを提供します。
 *
 * @generated by Claude 🤖
 */
export class DatabaseService implements IDatabaseService {
  private prisma: PrismaClient
  public readonly symbols: ISymbolRepository
  public readonly candles: ICandleRepository
  public readonly userPreferences: IUserPreferencesRepository

  constructor(prisma?: PrismaClient) {
    this.prisma = prisma || new PrismaClient()
    this.symbols = new SymbolRepository(this.prisma)
    this.candles = new CandleRepository(this.prisma)
    this.userPreferences = new UserPreferencesRepository(this.prisma)
  }

  async startTransaction(): Promise<DatabaseTransaction> {
    return this.prisma.$transaction(async tx => {
      const transactionService = {
        symbols: new SymbolRepository(tx as PrismaClient),
        candles: new CandleRepository(tx as PrismaClient),
        userPreferences: new UserPreferencesRepository(tx as PrismaClient),
        commit: async () => {
          // Transaction is automatically committed when the function returns successfully
        },
        rollback: async () => {
          throw new Error('Transaction rollback requested')
        },
      }
      return transactionService
    })
  }

  async isHealthy(): Promise<boolean> {
    try {
      await this.prisma.$queryRaw`SELECT 1`
      return true
    } catch (error) {
      console.error('Database health check failed:', error)
      return false
    }
  }

  async cleanup(): Promise<void> {
    await this.prisma.$disconnect()
  }
}

// Singleton instance
let databaseService: DatabaseService | null = null

/**
 * シングルトンのデータベースサービスインスタンスを取得します。
 *
 * インスタンスが存在しない場合は新しく作成し、既存のインスタンスがある場合は
 * それを返します。アプリケーション全体で単一のデータベース接続を維持します。
 *
 * @returns {DatabaseService} データベースサービスのシングルトンインスタンス
 *
 * @generated by Claude 🤖
 */
export function getDatabaseService(): DatabaseService {
  if (!databaseService) {
    databaseService = new DatabaseService()
  }
  return databaseService
}

/**
 * データベースサービスのシングルトンインスタンスをリセットします。
 *
 * 現在のインスタンスを null に設定し、次回 getDatabaseService() 呼び出し時に
 * 新しいインスタンスが作成されるようにします。主にテスト環境で使用されます。
 *
 * @generated by Claude 🤖
 */
export function resetDatabaseService(): void {
  databaseService = null
}
